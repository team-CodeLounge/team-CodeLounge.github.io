---
title: TCA
description: A reference page in my new Starlight docs site.
---

## viewModel의 한계
- viewModel으로 아키텍처를 구성하는 것은 초기에는 효율적이다.
- 앱의 규모가 커질 수록 여러 가지 구조적 문제가 발생한다.

## 문제
1. 상태의 분산 및 복잡한 계층 구조의 액션 전달
- viewModel은 일반적으로 view에 밀접하게 연결되어 해당 화면의 상태를 관리한다.
- 여러 화면이 동일한 상태를 공유해야 할 경우 viewModel을 전역으로 관리하거나 하위 뷰로 전달해야 한다.
- 이로 인해 상태 추적이 어려워지고 코드의 복잡도가 증가한다.
```swift
class HomeViewModel: ObdervableObject {
    @Published var isLoggedIn: Bool = false
}

// 기존의 해결법
// 1. viewModel을 공유
HomeView
    └── SubView1(viewModel: HomeViewModel)
        └── SubView2(viewModel: HomeViewModel)
            └── SubView3(viewModel: HomeViewModel)

// 2. completion Handler로 전달
HomeView
    └── SubView1(onLogin: () -> Void)
        └── SubView2(onLogin: () -> Void)
            └── SubView3(onLogin: () -> Void)
SubView3 -- (Action) -- SubView2 -- (Action) -- SubView1 -- (Action) -- HomeView

// TCA 해결법
SubView3 -- Login Action -- Store(단일 상태 원천) -- HomeView Reducer(tca의 viewModel같은 개념)
```

2. 코드 스타일의 불일치
- viewModel 패턴은 구현 방식에 대한 제약이 적어 개발자마다 상태 관리 및 로직 구현 방식이 상이하다.
- 이로 인해 코드의 일관성이 저하되고 유지보수 및 협업이 어려워진다.
- TCA로 해결: 
    - TCA는 State, Action, Reducer, Environment, View(Store)로 구성된 명확한 구조를 제공한다.
    - 모든 화면이 동일한 패턴으로 작성되므로 코드의 알관성이 높아지고 협업 및 유지보수가 용이하다.

3. 비동기 작업 처리의 용이성
- API 통신, 파일 입출력, 딜레이 등 비동기 작업은 viewModel에서 관리할 때 복잡성이 증가한다.
- 상태 업데이트, 작업 취소, 중복 호출 방지 등 다양한 이슈가 발생한다.
```swift
// 기존 viewModel 방식
func fetchData() {
    isLoading = true
    apiService.fetch { [weak self] result in
        self?.isLoading = false
        // 작업 처리
    }
}


// TCA 방식
// - TCA는 .run 이펙트 빌더와 Effect 타입을 통해 비동기 작업을 선언적으로 처리한다
// - 작업에 ID를 부여하여 취소 및 중복 관리가 용이하다
case .fetchData:
    state.isLoading = true
    return run { send in
        let result = await apiService.fetch()
        await send(.fetchDataResponse(result))
    } 
    .debounce(id: CancelID.search, for: 0.5, schedular: DispatchQueue.main)
    .cancellable(id: CancelID.search, cancelInFlight: true)
case .fetchDataResponse(let result):
    state.isLoading = false
    // 작업 처리
    return .none
```
<br/><br/>

![alt text](/images/part11/2025-12-09-tca1/image.png)
## State란?
- State는 화면을 표현하는 데 필요한 모든 상태 정보를 담고 있는 구조체입니다.
- `View`는 `State` 기반으로 화면을 렌더링하고 사용자의 입력은 `Action`을 통해 `Reducer`로 전달되어 `State`를 갱신하게 됩니다.
```swift
struct CounterState: Equatable {
    var count: Int = 0
    var isLoading: Bool = false
}
```
- State는 단순한 값 타입으로 앱의 특정 시점에 모든 데이터를 포함합니다.
- 특이한 점은 Equatable 프로토콜을 준수해야 한다는 점입니다.

### 왜 `Equatable`을 채택해야 하는가?
```swift
A type that can be compared for value equality.
```
- SwiftUI의 view는 상태가 바뀔때마다 `diff`알고리즘을 통해 필요한 부분만 다시 그립니다.
- TCA는 이 동작을 효율적으로 활용하기 위해 구조체에 `Equatable`을 요구합니다.
- 즉 값을 비교할 수 있어야 합니다.
- 비교를 해야 하는 이유
    - 성능 최적회: 상태 변경이 일어났는지 비교할 수 있어야 View가 필요할 때만 갱신됨
    - 불필요한 리랜더링 방지: 같은 상태인데 다시 그리는 걸 방지
    - 정확한 상태 추적: viewStore나 Reducer 등에서 상태 변화 감지를 정확하게 하기 위함
    - viewStore의 `removeDuplicates()`사용: 같은 값이 연속으로 들어오면 무시 가능(@ObservedObject의 성능 최적화)

### `Equatable` 필요한 예시
- `ViewStore`는 `State`의 변화를 관찰합니다.
- `Equatable`이 없다면 매번 값이 같아도 리렌더링 됩니다.
- 성능 낭비 + 깜빡임 등 UI 이슈가 발생할 수 있습니다.
```swift
struct CounterState: Equatable {
    var count: Int = 0
}
 
WithViewStore(self.store) { viewStore in
    Text("\(viewStore.count)")
}
```



## Action이란?
- 앱에서 발생할 수 있는 모든 사건을 나타냅니다. 사용자 입력이나 시스템 이벤트 등이 여기에 포함됩니다.
- 각 Action은 명확한 의도를 가지며 필요한 데이터를 함께 전달할 수 있습니다.
```swift
case TodoAction {
    case addTodo(String)                         // 할 일 추가
    case toggleTodo(UUID)                        // 할 일 완료 토글
    case deleteTodo(UUID)                        // 할 일 삭제
    case loadTodoResponse(Result<[Todo], Error>) // 할 일 목록 로드 응답
}

struct HomeView: View {
    @Bindable var store: StoreOf<HomeReducer>

    var body: some View {
        Button("추가") { store.send(.addTodo("코딩 하기")) }
    }
} 
```

## Reducer란?
- Action(사용자 입력, 이벤트 등)이 발생했을 때 State(앱의 상태)를 어떻게 변경할지를 결정하는 순수 함수입니다.
```swift
struct TodoReducer: Reducer {
    var body: some ReducerOf<Self> {
        Reducer { state, action in
            swith action {
                case .addTodo(let title):
                    let todo = Todo(id: UUID(), title: title, isComplecte: false)
                    state.todos.append(todo)
                    return .none
                case .toggleTodo(let id):
                    if let index = state.todos.firstIndex(where: { $0.id == id }) {
                        state.todos[index].isComplected.toggle() // state변경은 새로운 state를 생성해서(값복사) 내보낸다(직접 수정이 아니다)
                    }
                    return .none
                case .fetchData:
                    state.isLoading = true
                    return .run { send in
                        let result = await apiService.fetch()
                        await send(.fetchDataResponse(result))
                    }
            }
        }
    }
}
```
- Reducer는 순수 함수여야 합니다.(동일한 입력에 대해 항상 동일한 출력)
- 부수 효괴(Side Effect)를 직접 수행하지 않고 Effect를 반환합니다.
- State를 직접 변경(mutable)할 수 있습니다.(inout 파라미터로)

## 세 가지 개념
![alt text](/images/part11/2025-12-09-tca1/image2.png) 
<!-- - View에서 이벤트가 발생하면
- 특정 이벤트에 대한 Action이 발행
- send함수를 통해 Action을 Reducer에 전달
- Reducer는 Action을 보고 필요한 처리를 하고 State를 업데이트
- State를 바라보는 View가 State 변경점을 파악해서 리렌더링합니다. -->

- View는 State를 구독하고 화면에 표시합니다.
- 사용자 상호작용이나 시스템 이벤트가 발생하면 Action이 발생합니다.
- Reducer가 Action을 처리하여 State를 업데이트합니다.
- State가 변경되면 View가 자동으로 리렌더링됩니다.
-> 이러한 단방향 데이터 흐름은 앱의 상태 변화를 예측 가능하고 디버깅하기 쉽게 만듭니다.

### 예제
```swift
// State
struct CounterState: Equatable {
    var count = 0
}

// Action
enum CounterAction: Equatable {
    case increment
    case decrement
}

// Reducer
struct CounterReducer: Reducer {
    var body: some ReducerOf<Self> {
        Reduce { state, action in
            switch action {
                case .increment:
                    state.count += 1
                    return .none
                case .decrement:
                    state.count -= 1
                    return .none
            }
        }
    }
}
```

## Store란?
- Reducer는 State와 Action을 받아 새로운 State와 Effect를 반환하는 순수 함수였습니다.
- 누가 이 규칙을 실제로 실행하고 `Action`을 받고 `State` 변화를 `View`에 알려줄까요? => Store
- `Store`는 앱의 중심 허브입니다.
    - `State`, `Action`, `Reducer`를 모두 품고 있는 컨테이너이자 오케스트레이터입니다.
    - 간단히 말해 `Store`는 아래 3가지를 모두 하나의 객채로 통합한 구조입니다.
    1. State의 저장 및 관리
    2. Action의 처리 및 Reducer로의 전달
    3. Side Effect의 실행
    4. State 변경 사항을 view에 전파
    ```swift
    let store = Store(initialState: TodoState()) { // 초기 값
        TodoFeature() // Reducer
    }
    ```

### Store와 View의 연결: @Bindable
- TCA 1.0부터 @Observable을 기반으로 하는 Swift Concurrency와의 통합이 강화되었습니다.
- 이제 `View`는 `Store`를 직접 `@Bindable`로 감싸 `State` 변화에 반응할 수 있습니다.
```swift
// 최신 버전
struct TodoView: View {
    @Bindable var store: StoreOf<TodoFeature>
    
    var body: some View {
        List {
            ForEach(store.todos) { todo in
                Text(todo.title)
                    .onTapGesture {
                        store.send(.toggleTodo(todo.id))
                    }
            }
        }
        .onAppear{
            store.send(.loadTodos)
        }
    }
}

// 구버전
// 기존에는 WithViewStore로 따로 감싸주고 viewStore를 통해서 액션을 발행했음
// 최신 버전에서는 @Observable 매크로를 활용하여 @ObservableState 매크로가 TCA에서 제공됨
struct CounterView: View {
    let store = Store<CounterReducer.State, CounterReducer.Action>
    
    var body: some View {
        WithViewStore(self.store) { viewStore in
            VStack {
                Text("count: \(vireStore.count)")
                HStacj {
                    Button("감소") {
                        viewStore.send(.decrementButtonTapped)
                    }
                    Button("증가") {
                        viewStore.send(.incrementButtonTapped)
                    }
                }
            }
        }
    }
}
```

### @Bindable이란?
- @Bindable은 @Observable 객체의 프로퍼티를 SwiftUI에서 Binding으로 자동 변환해주는 역할입니다
```swift
// 기존 문제 (iOS 16까지)
@ObservedObject var vm: ViewModel
TextField("Name", text: $vm.name) // ❌

// 해결: Binding 자동 생성
@Bindable var vm: ViewModel
TextField("Name", text: $vm.name) // ✅
```

### 구버전과 차이
- 기존에는 WithViewStore로 따로 감싸주고 viewStore를 통해서 액션을 발행했습니다.
- TCA 최신버전에서는 Swift5.9의 @Observable 매크로를 활용한 @ObservableState 매크로가 TCA에서 제공됩니다.
- State가 Observable 프로토콜을 준수하게합니다.(@Observable 매크로는 class에서만 사용 가능하나 struct 메서드에서 유사하게 동작 하게 함)
- Store 자체를 @Bindable로 감싸서 직접 구독 가능해졌습니다.
-> SwiftUI의 @Bindable 프로퍼티 래퍼는 @Observable 객체를 View에 주입할 때 사용합니다.
-> @Bindable로 감싼 객체의 속성이 변경되면 SwiftUI는 해당 속성을 사용하는 View의 부분을 자동으로 업데이트합니다.
```swift
@ObservableState
struct State: Equatable {
    var count: Int = 0
}
```



<!-- ## Tca 아키텍처
- Redux같은 상태 관리 방식이다
- 관련 예) reswift, reactorkit

## 메모앱으로 예시
메모앱을 만든다면 메모가 도메인이다.

1. 도메인
- 문제 영역을 의미한다

2. 상태
- 도메인 상태를 의미한다

3. 액션
- 도메인의 액션
- 검색어 입력, 검색어 삭제 등
- 할일 삭제 등

4. 스토어
- 상태, 액션을 가지고 있음(커맨드 센터로서 작용)

5. 리듀서
- 액션과 상태를 연결시켜주는 역할
- 들어온 액션에 따라 상태를 변화시켜주는 역할

6. MVVM과의 차이
- MVVM은 뷰모델이 상태를 따로 관리
- 리덕스 관련 패턴은 스토어에서 종합적으로 관리
- 액션을 주면 상태를 받는 식

## Reference
- https://github.com/pointfreeco/swift-composable-architecture -->