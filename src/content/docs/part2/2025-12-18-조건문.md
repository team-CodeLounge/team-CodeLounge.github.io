---
title: 조건문(if, switch)
description: A reference page in my new Starlight docs site.
---

## 조건구문(Conditional Statements)
Swift에서는 코드에 조건부를 추가하는 if와 switch 두 가지 방법이 있습니다.  
- if 구문은 단순한 조건을 평가할 때 적합합니다.  
- switch 구문은 여러 가지 가능한 조합을 가진 더 복잡한 조건에 적합하고 패턴 일치를 통해 적절한 코드 분기를 선택하는데 유용합니다.

## Tip

### 단락 평가
조건을 왼쪽부터 평가하다가 이미 결과가 확정되면 나머지는 아예 평가하지 않는 방식입니다.

### &&(AND), ||(OR)
```swift
&&(AND)
첫 번째 조건이 false일 경우 Swift는 두 번째 조건을 확인하지 않습니다.
||(OR)
첫 번째 조건이 true일 경우 Swift는 두 번째 조건을 확인하지 않습니다.
```

### &&와 ,차이
Swift에서 &&와 ,는 모두 단락 평가를 수행하지만,
&&는 논리 계산을 위한 연산자이고,
,는 조건을 순차적으로 나열하기 위한 제어 문법입니다.
 
## if문
```swift
// 조건 = 참(true) 또는 거짓(false)을 판단할 수 있는 표현식
// 조건을 ,로 여러 개 연결할 수 있으며 AND(&&)와 같은 의미입니다.
if 조건 {
    // 조건이 true일 때 실행
}
```

### 예시1
```swift
let isLogin = true
let isAdult = true


// 같은 의미
if isLogin && isAdult {
    print("성인 로그인 사용자")
}


if isLogin, isAdult {
    print("성인 로그인 사용자")
}
```
- 위 두 코드는 평가 순서와 단락 평가 방식이 동일합니다.
- 왼쪽 조건부터 평가하며, 앞 조건이 실패하면 뒤 조건은 평가하지 않습니다.
- 차이점은 다음과 같습니다.
    - && : 논리 연산자 (Bool 값을 계산)
    - , : 조건을 나열하는 문법 (제어 흐름용)


### 예시2
```swift
// 순서가 필요한 조건 (옵셔널 바인딩)
if let a = b, a == c {
    // b에서 값 추출 성공 후 a == c 검사
}

// ❌ 컴파일 에러
// &&는 논리 연산자이므로 Bool && Bool 만 가능
if let a = b && a == c { }
```
- if let에서는 값 바인딩 → 조건 검사라는 순서가 필요합니다.
- ,는 앞 조건이 성공했을 때만 다음 조건을 평가하므로 이 순서를 표현할 수 있습니다.
- &&는 논리 연산자이기 때문에 옵셔널 바인딩과 함께 사용할 수 없습니다.

## switch문
- 값을 고려하고 가능한 여러개의 일치하는 패턴과 비교합니다.   
- 첫 번째로 일치하는 패턴을 기반으로 적절하 코드 블록을 실행합니다.  
- switch구문은 여러 가능한 상태에 응답하기 위해 if 구문의 대체 구문으로 제공합니다.
- C와 Objective-C의 switch와 다르게 swift의 switch구문은 각 케이스의 바닥이 다음 케이스로 바로 실행되지 않습니다. 
```swift
// 변수: 비교할 값(표현식)
// 값: 변수(표현식)에서 나올 수 있는 값들의 사례
switch 변수 {
case 값1:
case 값2, 값3:  // 여기서 ,는 or의 의미
case 값4:
default:       // 모든 케이스를 다루지 않는 경우 필요 
    break      // 실행하려는 코드가 없다면 반드시 break 기입
}
```

### switch의 case 조건
- 케이스를 조건에 따라 처리해야 하는 경우에 사용합니다.
```swift
switch num {
case let x where x % 2 == 0:
    print("짝수: \(x)")
default:
    print("홀수: \(num)")
}
```

### where 없이 조건 분리하기
- where 대신 case 순서로 조건을 표기할 수 있습니다.
```swift
// where 없이
// 값 바인딩 + 조건을 함께 사용할 수 있습니다.
// switch는 위에서 아래로 첫 번째로 일치하는 case만 실행합니다.
// 단순 범위 분기에 유리
let score = 85

switch score {
case 90...100: // 패턴매칭 -> 내부 구현 논리: 10...19 ~= age
    print("A")
case 80...89:
    print("B")
case 0..<80:
    print("C")
default:
    break
}

// where 존재
// case 내부에서 추가 조건을 명시적으로 표현할 때 사용합니다.
// 값 바인딩 + 조건을 함께 사용할 수 있습니다.
// 복잡한 조건에 유리
let score = 85

switch score {
case let x where x >= 90:
    print("A")
case let x where x >= 80:
    print("B")
case let x where x < 80:
    print("C")
default:
    break
}
```

### FallThrough
- `switch`는 기본적으로 한 case만 실행하고 종료합니다.
- 특정 switch 케이스 끝에서 명시적으로 다음 케이스로 떨어뜨리려면 fallthrough 키워드를 사용합니다.
- 주의점 ⚠️: 조건 검사 없이 무조건 다음 case로 이동하고, 다음 case 값 범위는 다시 검사하지 않습니다.

```swift
let score = 80
switch score {
case 90...100:
    print("A")
case 80...89:
    print("B")
    fallthrough
case 70...79:
    print("합격")
default:
    print("불합격")
}

// 결과
B
합격
```

### @unknown default
- enum을 switch로 분기할 때 사용합니다.
- Apple 프레임워크 enum처럼, iOS 업데이트로 새로운 case가 추가될 가능성이 있을 때 유용합니다.
    - default: 새로운 case가 추가되어도 컴파일러가 경고를 주지 않습니다.
    - @unknown default: 새로운 case가 추가되면 경고를 발생해줍니다.(안전장치)
```swift
// Apple 프레임워크 enum이라고 가정
// 현재는 두 case지만, 추후 새로운 case가 추가될 수 있음
enum Direction {
    case north, south
}

switch direction {
case .north:
    print("북")
case .south:
    print("남")
@unknown default:   // 안전장치
    print("알 수 없는 방향")
}
```

### default 없이 하는법
- switch는 모든 케이스를 처리하면 default가 필요없습니다.
```swift
enum State {
    case loading
    case success
    case failure
}

let state: State = .success

switch state {
case .loading:
    print("로딩 중")
case .success:
    print("성공")
case .failure:
    print("실패")
}
```

### 여러 case를 하나의 실행 블록으로 묶기
- 쉼표, 를 사용해 OR 조건처럼 처리할 수 있습니다.
```swift
let number = 2

switch number {
case 1, 3, 5:
    print("홀수")
case 2, 4, 6:
    print("짝수")
default:
    break
}
```

### 값 바인딩
- letm var를 사용해 case 내부에서 값을 바인딩 할 수 있습니다.
- 사실상 default와 동일하지만 값을 명시적으로 꺼내 쓸 수 있다는 점이 다릅니다.
```swift
let number = 10

switch number {
case let x:
    print("값은 \(x)")
}
```

### Optional 패턴
- optional도 switch로 안전하게 분기할 수 있습니다.
- if let의 switch 버전입니다,
```swift
let value: Int? = 5

switch value {
case .some(let v):
    print("값 있음: \(v)")
case .none:
    print("값 없음")
}
```

### 타입캐스팅 패턴
- Any, AnyObject를 다룰 때 사용합니다.
```swift
let value: Any = "Hello"

switch value {
case is Int:
    print("Int 타입")
case let str as String:
    print("String 값: \(str)")
default:
    print("기타 타입")
}
```

### 범위 패턴
```swift
let temperature = 30

switch temperature {
case ..<0:
    print("영하")
case 0...20:
    print("쌀쌀")
case 21...30:
    print("적당")
case 31...:
    print("더움")
default:
    break
}
```


### 튜플
- 하나의 switch 구문에 여러 값을 하나의 튜플로 묶어 분기할 수 있습니다.  
- 튜플의 각 요소는 서로 다른 값, 범위, 조건으로 비교할 수 있습니다.
- 가능한 어떠한 값도 일치하도록(특정 값은 무시하고 싶을 때) 와일드카드 패턴(wildcard pattern)으로 알려진 언더바 문자(_)를 사용할 수 있습니다.

1. 여러 값을 튜플로 묶어 분기
```swift
let point = (x: 0, y: 5)

switch point {
case (0, 0):
    print("원점")
case (0, 5):
    print("x=0, y=5")
default:
    print("기타 위치")
}
```

2. 튜플의 각 요소를 서로 다른 방식으로 바교(값/범위)
- math → 범위 비교
- english → 와일드카드로 무시
```swift
let score = (math: 85, english: 72)

switch score {
case (80...100, _):
    print("수학 A")
case (_, 80...100):
    print("영어 A")
default:
    print("보통 성적")
}
```

3. 튜플 + 조건(where)을 이용한 비교
```swift
let user = (age: 23, score: 78)

switch user {
case (let age, let score) where age < 25 && score >= 70:
    print("청년 우대 대상")
default:
    print("일반 대상")
}
```

4. 와일드카드 패턴 `_`사용
```swift
let size = (width: 100, height: 200)

switch size {
case (100, _):
    print("너비가 100")
case (_, 200):
    print("높이가 200")
default:
    break
}
```


## Reference
[Blog](https://alstn38.tistory.com/entry/Swift-단락-평가-Short-Circuit-Evaluation)